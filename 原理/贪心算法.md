

[122. 买卖股票的最佳时机 II_E](../explain/122.%20买卖股票的最佳时机%20II_E.md)

[134. 加油站_M](../explain/134.%20加油站_M.md)

[406. 根据身高重建队列_M](../explain/406.%20根据身高重建队列_M.md)

[765. 情侣牵手_H](../explain/765.%20情侣牵手_H.md)

[1221. 分割平衡字符串_E](../explain/1221.%20分割平衡字符串_E.md)


举个简单的例子，就能直观的展现贪心算法了。

比方说现在有两种钞票，面额分为为 1 元和 100 元，每种钞票的数量无限，但现在你只能选择 10 张，请问你应该如何选择，才能使得总金额最大？

那你肯定会说，这还用问么？肯定是 10 张全拿 100 元的钞票，共计 1000 元，这就是最优策略，但凡犹豫一秒就是傻瓜。

你这么说，也对，也不对。

说你对，因为这确实是最优解法，没毛病。

说你不对，是因为这个解法暴露的是你只想捞钱的本质 (¬‿¬) ，跳过了算法的产生、优化过程，不符合计算机思维。

那计算机就要提问了，[一切算法的本质是穷举](https://labuladong.online/algo/essential-technique/algorithm-summary/)，现在你还没有穷举出所有可能的解法，凭什么说这就是最优解呢？

按照算法思维，这个问题的本质是做 10 次选择，每次选择有两种可能，分别是 1 元和 100 元，一共有 210210 种可能的选择。

**所以你心里首先应该出现一棵高度为 10 的二叉树来穷举所有可行解，遍历这些可行解，然后可以得到最优解**。

心里只要有这样一棵二叉树，就应该能写出代码：

```
// 定义：做 n 次选择，返回可以获得的最大金额
int findMax(int n) {
    if (n == 0) return 0;
    
    // 这次选择 1 元，然后递归求解剩下的 n - 1 次选择的最大值
    int result1 = 1 + findMax(n - 1);
    // 这次选择 100 元，然后递归求解剩下的 n - 1 次选择的最大值
    int result2 = 100 + findMax(n - 1);

    // 返回两种选择中的最大值
    return Math.max(result1, result2);
}
```

这个算法的复杂度是二叉树的节点数量，是指数级别，非常高。不过到这里你应该已经看出来了，`findMax(n - 1)` 的值肯定都一样，那么 `100 + findMax(n - 1)` 必然大于 `1 + findMax(n - 1)`，因此可以进行优化：

```
// 优化一、没必要对两种选择进行比较了
int findMax(int n) {
    if (n == 0) return 0;
    int result = 100 + findMax(n - 1);
    return result;
}

// 优化二、递归改为迭代
int findMax(int n) {
    int result = 0;
    for (int i = 0; i < n; i++) {
        result += 100;
    }
    return result;
}

// 优化三、直接计算结果就行了
int findMax(int n) {
    return 100 * n;
}
```

这就是贪心算法，复杂度从 O(2^n) 优化到了 O(1)，堪称离谱。

你可能会认为这个例子太简单？

其实算法本来就很简单，就是穷举，有什么了不起的嘛？围绕穷举，衍生出各种优化方法，起了些花里胡哨的名字，不懂的人就容易被名字骗到，其实从原理上讲，没多大差别，不过是见招拆招罢了。

上面的例子虽然简单，但已经蕴含了贪心算法的精髓。接下来我们拓展延伸一下，在真实的算法问题中，如何发现贪心选择性质，如何用贪心算法解决问题。

## 贪心选择性质

首先来举例说明什么是贪心选择性质。

本文开头举例的这个最大金额的问题符合贪心选择性质，所以我们可以用贪心算法，把 O(2n)O(2n) 的暴力穷举算法直接优化到了 O(1)O(1)。

作为对比，我们稍微改一改题目：

现在有两种钞票，面额分别为 1 元和 100 元，每种钞票的数量无限。现在给你一个目标金额 `amount`，请问你最少需要多少张钞票才能凑出这个金额？

这道题其实就是 [322. 零钱兑换](../explain/322.%20零钱兑换.md)。

**为了方便讲解，本文开头的最大金额问题我们称为「问题一」，这里的最少钞票数量问题我们称为「问题二」**。

我们是如何解决问题二的？首先也是抽象出递归树，写出指数级别的暴力穷举算法，然后发现了重叠子问题，于是用备忘录消除重叠子问题，这就是标准的动态规划算法的求解过程，不能再优化了。

所以，问题二和问题一到底有什么区别？区别在于，前者没有贪心选择性质，而后者有。

贪心选择性质就是说能够通过局部最优解**直接**推导出全局最优解。

结合案例来说，对于问题一，局部最优解就是每次都选择 100 元，因为 100 > 1；对于问题二，局部最优解也是每次都选择 100 元，因为每张面额尽可能大，所需的钞票数量就能尽可能少。

但区别在于，问题一中每一次选择的局部最优解组合起来就是全局最优解，而问题二中不是。

比方说目标金额 `amount = 3`，虽然每次选择 100 元是局部最优解，但想凑出 3 元，只能选择 3 张 1 元，局部最优解不一定能构成全局最优解。

对于问题二的场景，不符合贪心选择性质，所以不能用贪心算法，只能穷举所有可行解，才能计算出最优解。

贪心选择性质 vs 最优子结构

[动态规划](动态规划.md) 中提到，算法问题必须要有「最优子结构」性质，才能通过子问题的最优解推导出全局最优解，这是动态规划算法的基础。

那么这个「贪心选择性质」和「最优子结构」有什么区别？

最优子结构的意思是说，现在我**已经把所有子问题的最优解都求出来了**，然后我可以基于这些子问题的最优解推导出原问题的最优解。

贪心选择性质的意思是说，我只需要进行一些局部最优的选择策略，就能直接知道哪个子问题的解是最优的了，且这个局部最优解可以推导出原问题的最优解。此时此刻我就能知道，**不需要等到所有子问题的解算出来才知道**。

所以贪心算法的效率一般都比较高，因为它不需要遍历完整的解空间。

## 例题实战

[55. 跳跃游戏](../explain/55.%20跳跃游戏.md)

[45. 跳跃游戏 II](../explain/45.%20跳跃游戏%20II.md)

在实际的算法题中，贪心选择性质一般比较容易看出来。

不过就算没看出来也没关系，先写出暴力穷举算法求解，使用备忘录等常规手段进行优化，如果都不奏效，就可以往贪心算法上想。

具体怎么想呢？你可以仔细观察题目，是否可以在不计算所有子问题的解的情况下，通过局部最优解推导全局最优解。如果可以，那基本就能断定这个问题可以用贪心算法解决。

另外，「贪心算法」和「贪心思想」这两个概念还不太一样。

满足贪心选择性质的题目才能用贪心算法，一旦用出来可以大幅提升算法效率。但贪心思想是一种更广泛的优化思路，类似于剪枝优化，可以运用在其他算法中，优化穷举的效率。



