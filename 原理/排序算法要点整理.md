# 排序算法要点整理

概念：原地排序，排序算法的稳定性

基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

逆序度=满有序度-有序度，满有序度=n(n-1)/2。排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，说明排序完成。

以从小到大排序为例。

**冒泡排序**：每次比较相邻的两个元素。一次冒泡会使得最大的元素到数组的末尾。

代码关键：两层for循环，第一层遍历所有元素n，第二层遍历n-i-1内的元素。相邻元素两两比较，交换。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，可以直接退出。

是原地排序算法，稳定的排序。

**鸡尾酒排序**：冒泡排序的一种改进。一次冒泡将最大元素放到数组末尾（从低到高遍历），一次冒泡将最小元素放到数组开头（从高到低遍历）

**选择排序**：初始时在序列中找到最小元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

代码关键：两层for循环，第一层遍历所有元素n-1（其实是已排序序列的末尾index），第二层在剩下元素中寻找最小的元素，与位置index交换

是原地排序算法，不稳定的排序。

**插入排序**：取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。

代码关键：两层for循环，第一层遍历所有未排序区间元素，第二层倒序遍历已排序区间，两者比较，大于当前元素则后移，给新元素提供插入位置。

是原地排序算法，稳定的排序。适合处理数据量较少或者部分有序的数据

改进：二分插入排序，即第二层遍历的时候可以用二分查找法寻找插入点。

希尔排序：

**归并排序**：递归实现和迭代实现。

不是原地排序算法，是稳定的排序

**堆排序**：堆调整是核心

是原地排序算法，不稳定排序

python的heapq

**快速排序**：选择比较基准，分区。分治思想

原地排序，不稳定

**桶排序**：将数组元素映射到有限数量个桶里，每个桶各自进行桶内排序，最后将多个桶的排序结果合并。桶与桶之间天然有序，不需要排序。

稳定

计数排序：

基数排序：将所有待比较正整数统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始进行基数为10的计数排序，一直到最高位计数排序完后，数列就变成一个有序序列（利用了计数排序的稳定性）。
