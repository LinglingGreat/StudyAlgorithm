逻辑结构就是数据之间的关系。而按数据之间的关系来说，逻辑结构大概可以分为两种：**线性结构**和**非线性结构（集合、树、图）。**

而对应的物理结构是指存储结构，存储结构有**顺序存储、链式存储、索引存储**以及**散列存储（哈希表）**。

## 二分查找

**若有 18 个元素的有序表存放在一维数组 A[19]中，第一个元素放 A[1]中，现进行二分查找，则查找 A[3]的比较序列的下标依次为（）**
A.1，2，3
B.9，5，3
C.9，5，2，3
D.9，4，2，3
答案：D
解析：
注意第一个元素是放在 A【1】,一共 18 个元素，也就是 A【1】~A[18]。
第一次： low=1，high=18 ，mid=9(9.5 向下取整)。A【3】和 A【9】比较。然后把 A【9】右面的包括 A【9】全部抛弃掉。
第二次：A[1]~A [8]. mid=4(向下取整)。然后把 A【4】右面的包括 A【4】全部抛弃掉
第三次：Ａ【１】～Ａ【３】，mid=2。然后把 A【２】左面的包括 A【２】全部抛弃掉。
第四次；Ａ【３】和Ａ【３】比较。

## 栈&队列&链表&散列表

**下面数据结构能够支持随机的插入和删除操作、并具有较好的性能的是 **

```
链表和哈希表
数组和链表
哈希表和队列
堆栈和双向队列
```

链表和哈希表

**下列关于线性表，平衡二叉树，哈希表存储数据的优劣描述错误的是？**
A、哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为 O(1)；
B、线性表实现相对比较简单
C、平衡二叉树的各项操作的时间复杂度为 O（logn）
D、平衡二叉树的插入节点比较快
答案：D
解析：
在平衡二叉树中插入节点后需要保持整棵数的平衡性，所以还需要一次或者多次的树旋转来重新平衡这个树，其余选项为正确的

**某一系统功能,需要一次性加载 N(N 在 1000 左右)个随机数,后续只对该集合进行遍历.最宜采用哪种结构存放？**
A、Hash 表
B、链表
C、图
答案：B
解析：
1.Hash 表不适合遍历，利用 Hash 算法来决定存储位置，
2.链表适合遍历但是不适合随机访问
3.图用于表示物件与物件之间关系的数学对象，但是不强调数据之间的关系，遍历效率不如链表

### 栈

**下列说法错误的是 () **

```
利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素,这种形式的栈也称为顺序栈
top=0 时为空栈,元素进栈时指针 top 不断地减 1
当top等于数组的最大下标值时则栈满
栈不能对输入序列部分或全局起求逆作用
```

BD

A正确，虽然链栈也可以实现地址连续，但无法做到依次存放数据元素，因为除了元素域还需要存放指针域。因此满足条件的只有顺序栈。

B错误，top= -1时为空栈，top=0只能说明栈中只有一个元素，并且元素进栈时top应该自增

C正确，top所指向的对象永远是栈顶元素

D错误，栈的特性（先进后出）就决定了可以作为求逆元素的辅助空间。所谓求逆运算就是ABC依次入栈，输入CBA。

### 队列

**判定一个循环队列Q（最多元素为m0）为满队列的条件是（） **

```
Q.front==(Q.rear+1)MOD m0
```

**设数组Data[0..m-1]作为循环队列SQ的存储空间，front为队头指针，rear为队尾指针，则执行出队操作的语句为（） **

```
front=(front+1)%m
```

举个例子就好了，假如循环队列由m(最大长度)等于6的数组(假设下标从一开始)来实现。当front等于6的时候，需要出队，直接+1等于7肯定会越界，所以采用front＝(front+1)%m 



### 链表

**在有n个节点的二叉链表中，值为空的链域的个数为（） **

n+1

解法1：

度为0的节点n0，有2个空的链域。度为1的节点n1，有1个空的链域。度为2的节点n2,没有空链域。

因为n0+n1+n2=n。n2=n0-1(度为2的节点个数比度为0的节点个数少一 )。所以2n0+n1-1=n。

而空链域的个数为2n0+n1，所以为n+1。

解法2：因为一共必有2n个链域。除根结点外，每个结点有且仅有一个双亲，所以只会有n－1个结点的链域存放指针，指向非空子女结点。2n-(n-1) = n+1 

**下列叙述中错误的是（ ） **

```
二叉链表是二叉树的存储结构
循环链表是循环队列的存储结构
栈是线性结构
循环队列是队列的存储结构
```

B，循环队列是队列的一种顺序存储结构，用队尾指针 rear 指向队列中的队尾元素，用排头指针 front 指向排头元素的前一个位置。循环链表是用不连续的存储单元存储数据，它有一个表头结点，队头指针指向表头结点，最后一个结点的指针域指向表头结点。二叉链表是树的二叉链表实现方式。栈是一种特殊存取方式的线性表。故本题答案为 B 选项。 

**设一个链表最常用的操作是在末尾插入结点和删除尾结点,则选用()最节省时间 **

```
带头结点的双循环链表
单循环链表
带尾指针的单循环链表
单链表
```

A。C是加入好加，但是删除不好删，因为需要找到末尾节点的前一个节点

不带头节点的话你就需要在其他地方存储链表的长度了吧。带头节点的链表如果在头节点不存储链表长度而是 直接存储尾节点的地址，这样就可以达到最省了。

**线性表有两种存储结构**：
1.顺序存储结构---顺序表。顺序表以数组形式出现，可以取任意下标访问，所以是一种随机存取的存储结构。
2.链式存储结构---链表。链表以链表的形式出现，必须从头开始访问，所以是一种顺序存取的存储结构。

### 散列表

**以下说法正确的是 。 **

```
散列法存储的思想是由关键字值决定数据的存储地址
散列表的结点中只包含数据元素自身的信息，不包含指针
负载因子是散列表的一个重要参数，它反映了散列表的饱满程度
散列表的查找效率主要取决于散列表构造时选取的散列函数和处理冲突的方法
```

C

A：散列法存储的思想是由关键字和散列函数共同决定数据的存储地址的。

B：对于拉链法来说，数组的每一个节点指向一个链表，链表中的每一个节点都存储了散列值为该索引的键值对，**而链表的维护需要节点之间的指针来维护**！

D：散列表的查找效率主要取决于散列函数、处理冲突的方法和**装载因子**

**散列表，线性探测法，等概率成功查找的平均查找长度**

即分配元素后，查找每个元素所需要的次数的均值，具体例子见

https://blog.csdn.net/u013806583/article/details/52643541

## 树

### 二叉树

**深度为h的满m叉树的第k层有()个结点(1<=k<=h) **

$$m^{k-1}$$

满m叉树 第n层节点数肯定是前一层的m倍 

**一棵有124个叶结点的完全二叉树，最多有（ ）个结点 **

248

一棵124个叶结点的完全二叉树，假设n0为叶子结点数，n1为度为1结点数，n2为度为2结点数，则有总结点数为n0+n1+n2;而n2=n0-1=123；且完全二叉树中度为1的结点只能为一个或0个，所以总结点数为124+1+123=248个

**用常规的非递归方法遍历一个平衡二叉树，所需的时间复杂度和空间复杂度是？（） **

O(n)，O(n)

遍历二叉树的算法中的基本操作是访问结点，则不论按哪一种次序进行遍历，对n个结点的二叉树，其时间复杂度均为O(n)。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为n,则空间复杂度也为O(n)。 

**二叉树插入的时间复杂度**

```
二叉查找树的查找、插入的时间复杂度O(logn)
```

 查找     插入      删除

数组            o(n)        o(1)        o(n)

有序数组     o(lgn)      o(n)        o(n)

链表            o(n)        o(1)       o(n)

有序链表      o(n)        o(n)        o(n)

二叉树最坏   o(n)        o(n)        o(n)

二叉树一般   o(lgn)     o(lgn)      o(lgn)

平衡树         o(lgn)     o(lgn)      o(lgn)

哈希表         o(1)        o(1)        o(1)

**一颗完全二叉树第六层有8个叶结点（根为第一层），则结点个数最多有（）个。 **

完全二叉树第六层8个叶结点，则第七层缺少16个结点不满，结点个数等于27 -1-16=111 

**⼀个完全⼆叉树中有330个叶子节点, 则在该⼆叉树中的节点个数为（）？ **

 完全二叉树除最后一层外都是满的，所以也可以这么算：第一层1个节点，令层数为n，除最后一层外，每层的节点个数为2^(n-1)，有330个叶子节点，所以倒数第二层为第9层，有256个节点，256+x=330得x=74,所以共有1+2+4+8+16+32+64+128+256+74*2=659个节点，又因为第659个节点是右子节点，所以节点个数也可以是660 

  因为二叉树度为2的结点n2和叶子结点存在n0：n0=n2+1的关系，所以度为2的结点个数为329，又因为完全二叉树可能存在度为1的结点，所以结点个数为：330+329=659或330+329+1=660. 

**有n个元素的完全二叉树的深度是 D(n)=1+log2(n)**

**树的先序对应二叉树的先序**

**树的后序对应二叉树的中序**

![img](http://uploadfiles.nowcoder.net/images/20151221/801749_1450662572170_4A47A0DB6E60853DEDFCFDF08A5CA249)

### 哈夫曼树

**给定权值{1,6,7,8,8,10}构建哈夫曼树，带权路径长度为（） **

101

一开始要构造哈夫曼树， 1.先找权值最小的二个节点，构造二叉树 2.将这二个节点之和，放入这些权值中 3.继续找权值最小的二个节点

![img](https://uploadfiles.nowcoder.com/images/20180223/1042593_1519365227989_F753C3A75140EF4445B7E6826161C842) 

https://blog.csdn.net/u013011841/article/details/38226099

**哈夫曼树是带权路径长度最短的树，也叫最优二叉树。 **

哈夫曼树中没有度为1的结点，n0=n2+1，总结点数为n0+n2

## 堆

**关于序列16 14 10 8 7 9 3 2 4 1的说法下面哪一个正确（） **

```
大顶堆
小顶堆
不是堆
二叉排序树
```

A

小顶堆：父节点上的值比左右孩子上的值小，且所有子树都满足 

大顶堆：父节点上的值比左右孩子上的值大，且所有子树都满足 

二叉排序树：若左孩子不为null，则其值比父节点小；若右孩子不为null。则其值比父节点大。且所有子树都满足。也就是说根节点值比左子树上的都大，比右子树上的都小。所有子树都满足。 

**最小堆[0,3,2,5,7,4,6,8],在删除堆顶元素 0 之后，其结果是（）**
A.[3，2，5，7，4，6，8]
B.[2，3，5，7，4，6，8]
C.[2，3，4，5，7，8，6]
D.[2，3，4，5，6，7，8]
答案：C
解析：
根据堆的删除规则，删除操作只能在堆顶进行，也就是删除 0 元素。然后让最后一个节点放在堆顶，做向下调整工作，让剩下的数组依然满足最小堆。
删除 0 后用 8 填充 0 的位置，为[8,3,2,5,7,4,6]
然后 8 和其子节点 3,2 比较，结果 2 最小，将 2 和 8 交换，为：[2,3,8,5,7,4,6]
然后 8 的下标为 2，其两个孩子节点下标分别为 2*2+1=5,2*2+2=6
也就是 4 和 6 两个元素，经比较，4 最小，将 8 与 4 交换，为[2,3,4,5,7,8,6]
这时候 8 已经没有孩子节点了，调整完成。

## 图

**下列关于图的叙述中，正确的是（）。**

  Ⅰ．回路是简单路径  Ⅱ．存储稀疏图，用邻接矩阵比邻接表更省空间  Ⅲ．若有向图中存在拓扑序列，则该图不存在回路  

仅III

回路：第一个顶点和最后一个顶点相同的路径称为回路（环）。

简单路径：在一条路径中，若没有重复相同的顶点，该路径称为简单路径。

简单回路：在一个回路中，除了第一个与最后一个顶点外，其余顶点不重复出现的回路称为简单回路（简单环）。

回路对应于路径，简单回路对应于简单路径。

II：存储稀疏图时，邻接表只存储了有数据的节点，因此相比邻接矩阵更节省空间。 

III:若有向图中存在拓扑序列，则说明该图不存在回路。

有向图的拓扑序列： 对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个 [全序](http://baike.so.com/doc/666937-705979.html) ，这个操作称之为拓扑排序（360百科），从定义可以看出不能存在回路。 

**在有向图的邻接表存储结构中,顶点v在链表中出现的次数是() **

```
顶点v的度
顶点v的出度
顶点v的入度
依附于顶点v的边数
```

C，对于有向图，vi的邻接表中每个表结点都对应于以vi为始点射出的一条边。因此，将有向图的邻接表称为出边表。

所以顶点V在链表中出现的次数是顶点V的入度

**图G是n个顶点的无向完全图,则下列说法正确的有:() **

```
G的邻接多重表需要n(n-1)个边结点和n个顶点结点
G的连通分量个数最少
G为连通图
G所有顶点的度的总和为n(n-1)
```

BCD

在无向图中，如果从顶点vi到顶点vj有路径，则称vi和vj连通。如果图中任意两个顶点之间都连通，则称该图为连通图，否则，称该图为非连通图，则其中的极大连通子图称为连通分量，这里所谓的极大是指子图中包含的顶点个数极大。

A,边的条数为C（n,2）=n(n-1)/2

B,G是完全图，必定是连通图。所以连通分量只有其自身

C，G是完全图，必定是连通图

D，每个顶点都与其余n-1个顶点相连，则n个顶点度的和为n(n-1)

**存在拓扑有序的图中的拓扑序列不唯一**

**无向图的邻接矩阵可用一维数组存储。（） **

正确

习惯上无向图的邻接矩阵一般用二维数组存储，这样使用方便。当然，任意二维数组都是可以用一维数组存储的，只是用起来不方便。

**当各边上的权值(  )时，BFS算法可用来解决单源最短路径问题。 **

```
均相等
均互不相等
不一定相等
```

当权值相同，则最短路径问题转化为求边数最少的问题，BFS可以保证求得源点到汇点的最少边数。 

**判断有向图是否存在回路，利用( )方法最佳 。**
A、拓扑排序
B、求最短路径
C、求关键路径
D、广度优先遍历
答案：A
解析：
拓扑排序主要是对有向无环图进行排序，步骤是 
1.选择入度为 0 的顶点并输出；
2.从网中删除此顶点及所有出边。循环执行这两个步骤，直到不存在入度为 0 的顶点为止。
拓扑排序每次选的点都是入度为 0 的点，如果没有这样的点，就不能构成拓扑排序，则可以判断是存在回路的。

**n 个结点的完全有向图含有边的数目()**

有向完全图：图中各边都有方向，且每两个顶点之间都有两条方向相反的边连接的图。
有向图：n\*(n-1)
无向图：n*(n-1)/2

## 其它



**已知一稀疏矩阵的三组元表为：（1，2，3），（1，6，1），（3，1，5）（3，2，-1），（5，4，5）（5，1，-3），则其转置矩阵的三元组表中第3个三元组为（） **

```
(2, 1, 3)
(3, 1, 5)
(3, 2, -1)
(2, 3, -1)
```

A

根据三元组表可以得到稀疏矩阵，三元组表中：第一个数表示非零元素在稀疏矩阵中的行号，第二个数表示非零元素在稀疏矩阵中的列号，第三个数是非零元素的值。 把稀疏矩阵转置为矩阵的时候，只需要把行和列互换即可。再把矩阵的三元组表（定义是相同的）写出来就知道答案是 A 

**设A是n*n的对称矩阵，将A的对角线及对角线上方的元素以列为主的次序存放在一维数组B[1..n(n+1)/2]中，对上述任一元素aij(1≤i，j≤n，且i≤j)在B中的位置为(  ) **

```
i(i-l)/2+j
j(j-l)/2+i
j(j-l)/2+i-1
i(i-l)/2+j-1
```

B

因为是以列为主， 所以存储的序列个数为1， 2， 3…. j 
对于aij， 就应该存在(注意i， j都是大于等于1的） 
1 + 2 + 。。。。 + j -1 + i（最后一列只有i个）= j(j-1)/2 + i

**树形结构元素之间存在一对多的关系，线性结构元素之间存在一对一的关系，图形结构元素之间存在多对多的关系。 **

**有B+Tree/Hash_Map/STL Map三种数据结构。对于内存中数据，查找性能较好的数据结构是（），对于磁盘中数据，查找性能较好的数据结构是（）。 **Hash_Map/B+Tree

Hash操作能根据散列值直接定位数据的存储地址，设计良好的hash表能在常数级时间下找到需要的数据，但是更适合于内存中的查找。 B+树是一种是一种树状的数据结构，适合做索引，对磁盘数据来说，索引查找是比较高效的 STL_Map的内部实现是一颗红黑树，但是只是一颗在内存中建立二叉树树，不能用于磁盘操作，而其内存查找性能也比不上Hash查找。 因此对于内存中数据，查找性能较好的数据结构是Hash_Map，对于磁盘中数据，查找性能较好的数据结构是B+Tree。 

**下列算法中，没有使用贪心策略的是（）**
A、 Prim 算法
B、 Kruskal 算法
C、 Dijkstra 算法
D、 KMP 算法
答案：D
解析：
贪心策略是在对问题求解时，总是做出在当前看来是最好的选择，且缺少约束条件。也就是说，贪心策略不从整体最优上加以考虑，在某种意义上求得的是局部最优解。
Prim 算法属于贪心策略，先任意选择一个初始起点，构造顶点集，寻找与顶点集相邻权值最小的边和另一顶点，从而扩充顶点集，最后构造出最小生成树
Kruskal 算法通过合并顶点所在的子集合，选择边上权值最小的顶点集合进行联合，直到涵盖所有的顶点，生成最小生成树
Dijkstra 算法是解单源最短路径的贪心算法，通过扩充顶点集，不断做贪心选择来进行扩充
KMP 算法是一种改进的字符串匹配算法，时间复杂度是 O（m+n），主要使用的是递推的方法，没有涉及贪心策略

**大整数 845678992357836701 转化成 16 进制表示,最后两位字符是?**
A、AB
B、EF
C、8B
D、9D
答案：D
解析：
方法一：
将 10 进制转化为 2 进制，再转化为 16 进制；10 进制转化成 2 进制采用取余的方法，因为是倒着取余，所以只需计算后 8 位，为 10011101，转化为 16 进制时，注意2 进制转化 16 进制可以每四位进行切分，对应以下转换表可得，1001——9,；1101——D，所以末尾两位为 9D
转换表：
0001——1
0010——2
0011——3
0100——4
0101——5
0110——6
0111——7
1000——8
1001——9
1010——A
1011——B
1100——C
1101——D
1110——E
1111——F
方法二：
使用排除法，利用同余关系进行，845678992357836701 除以 4 余数为 1，16 进制数中决定除以 4 后余数的只有最后一位，选项中只有 D（十进制中的 13）除以 4 余数是 1，所以选择 D

**缓存系统中的主要使用的数据结构是()**

```
HashSet
Array
HashMap
LinkedList
```

常用的缓存系统有：redis、memcached。它们的存储结构都是key-value类型的数据结构，而HashMap就是key-value结构

**STL中的unordered_map和priority_queue使用的底层数据结构分别是什么?()**

```
rbtree,queue
hashtable,heap
rbtree,heap
hashtable,queue
```

B

**基于哈希的索引和基于树的索引有什么区别?**

```
hash索引仅满足“=”、“IN”和“<=>”查询，不能使用范围查询
hash索引无法被用来进行数据的排序操作
对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用
Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高
```

ABCD

1、hash索引仅满足“=”、“IN”和“<=>”查询，不能使用范围查询

因为hash索引比较的是经常hash运算之后的hash值，因此只能进行等值的过滤，不能基于范围的查找，因为经过hash算法处理后的hash值的大小关系，并不能保证与处理前的hash大小关系对应。

2、hash索引无法被用来进行数据的排序操作

由于hash索引中存放的都是经过hash计算之后的值，而hash值的大小关系不一定与hash计算之前的值一样，所以数据库无法利用hash索引中的值进行排序操作。

3、对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。

4、Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。

对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。





