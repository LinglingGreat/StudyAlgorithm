## 理论篇

[12【数据结构与算法】二叉树](../原理/12【数据结构与算法】二叉树.md)

## 刷题篇
### 题目

[94. 二叉树的中序遍历](../explain/94.%20二叉树的中序遍历_E.md)

[96. 不同的二叉搜索树](../explain/96.%20不同的二叉搜索树_M.md)

[101. 对称二叉树](../explain/101.%20对称二叉树_E.md)

[104. 二叉树的最大深度](../explain/104.%20二叉树的最大深度_E.md)

[105. 从前序与中序遍历序列构造二叉树](../explain/105.%20从前序与中序遍历序列构造二叉树_M.md)

[110. 平衡二叉树](../explain/110.%20平衡二叉树_E.md)

[112.路径总和](../explain/112.路径总和_E.md)

[113.路径总和II](../explain/113.路径总和II_M.md)

[129. 求根到叶子节点数字之和](../explain/129.%20求根到叶子节点数字之和_M.md)

[144. 二叉树的前序遍历](../explain/144.%20二叉树的前序遍历_M.md)

[173. 二叉搜索树迭代器](../explain/173.%20二叉搜索树迭代器_M.md)

[199. 二叉树的右视图](../explain/199.%20二叉树的右视图_M.md)

[235. 二叉搜索树的最近公共祖先](../explain/235.%20二叉搜索树的最近公共祖先_E.md)

[236.二叉树的最近公共祖先](../explain/236.二叉树的最近公共祖先_M.md)

[257.二叉树的所有路径](../explain/257.二叉树的所有路径_E.md)

[297. 二叉树的序列化与反序列化_H](../explain/297.%20二叉树的序列化与反序列化_H.md)

[513. 找树左下角的值](../explain/513.%20找树左下角的值_M.md)

[684. 冗余连接](../explain/684.%20冗余连接_M.md)

[685. 冗余连接 II](../explain/685.%20冗余连接%20II_H.md)

[814. 二叉树剪枝_M](../explain/814.%20二叉树剪枝_M.md)

[剑指 Offer 32. 从上到下打印二叉树](../explain/剑指%20Offer%2032.%20从上到下打印二叉树_M.md)

### 模板

[0.二叉树](../code/0.二叉树.py)

[0.二叉树遍历模板](../code/0.二叉树遍历模板.py)

### 二叉树的深度优先搜索

常见考题一：二叉树的前序中序后序遍历，递归和迭代实现，一共6种情况。

不管是哪种深度优先搜索算法，也不管是递归代码还是迭代代码，如果二叉树有n个节点，那么它们的时间复杂都是O（n）。如果二叉树的深度为h，那么它们的空间复杂度都是O（h）。在二叉树中，二叉树的深度h的最小值是log2（n+1），最大值为n。

[814. 二叉树剪枝_M](../explain/814.%20二叉树剪枝_M.md)

[297. 二叉树的序列化与反序列化_H](../explain/297.%20二叉树的序列化与反序列化_H.md)

[129. 求根到叶子节点数字之和_M](../explain/129.%20求根到叶子节点数字之和_M.md)

与二叉树中路径相关的面试题有很多，通常这些面试题都可以用深度优先搜索解决，很少采用广度优先搜索。这是因为路径通常顺着指向子节点的指针的方向，也就是纵向方向，这更加符合深度优先搜索的特点。广度优先搜索是从左到右遍历每层的节点，是横向的遍历。因此，深度优先搜索更加适合解决与路径相关的面试题。

[437. 路径总和 III_M](../explain/437.%20路径总和%20III_M.md)

[124. 二叉树中的最大路径和_H](../explain/124.%20二叉树中的最大路径和_H.md)

### 二叉搜索树

二叉搜索树是一类特殊的二叉树，它的左子节点总是小于或等于根节点，而右子节点总是大于或等于根节点。

由于中序遍历按照节点值递增的顺序遍历二叉搜索树的每个节点，因此中序遍历是解决二叉搜索树相关面试题最常用的思路。

在普通的二叉树中根据节点值查找对应的节点需要遍历这棵二叉树，因此需要O（n）的时间。但如果是二叉搜索树就可以根据其特性进行优化。如果当前节点的值小于要查找的值，则前往它的右子节点继续查找；如果当前节点的值大于要查找的值，则前往它的左子节点继续查找，这样重复下去直到找到对应的节点为止。如果二叉搜索树的高度为h，那么在二叉搜索树中根据节点值查找对应节点的时间复杂度是O（h）。

[897. 递增顺序搜索树_E](../explain/897.%20递增顺序搜索树_E.md)

[剑指 Offer II 053. 二叉搜索树中的中序后继_M](../explain/剑指%20Offer%20II%20053.%20二叉搜索树中的中序后继_M.md)

[538. 把二叉搜索树转换为累加树_M](../explain/538.%20把二叉搜索树转换为累加树_M.md)

[173. 二叉搜索树迭代器_M](../explain/173.%20二叉搜索树迭代器_M.md)

[653. 两数之和 IV - 输入 BST_E](../explain/653.%20两数之和%20IV%20-%20输入%20BST_E.md)


### Treeset和Treemap

二叉搜索树是一种很有用的数据结构。如果二叉搜索树有n个节点，深度为h，那么查找、添加和删除操作的时间复杂度都是O（h）。如果二叉搜索树是平衡的，那么深度h近似等于logn。但在极端情况下（如每个节点只有一个子节点），树的深度h等于n-1，此时二叉搜索树的查找、添加和删除操作的时间复杂度都退化成O（n）。二叉搜索树是否平衡对二叉搜索树的时间效率至关重要。

实现一棵平衡的二叉搜索树对于面试来说不是一件容易的事情。Java根据红黑树这种平衡的二叉搜索树实现TreeSet和TreeMap两种数据结构.

[220. 存在重复元素 III_M](../explain/220.%20存在重复元素%20III_M.md)

[729. 我的日程安排表 I_M](../explain/729.%20我的日程安排表%20I_M.md)






