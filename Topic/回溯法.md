## 回溯法

[112.路径总和](../explain/112.路径总和_E.md)
[113.路径总和II](../explain/113.路径总和II_M.md)
[200.岛屿数量](../explain/200.岛屿数量_M.md)

[22.括号生成_M](../explain/22.括号生成_M.md)

[37.解数独_H](../explain/37.解数独_H.md)

[39. 组合总和_M](../explain/39.%20组合总和_M.md)

[40. 组合总和 II_M](../explain/40.%20组合总和%20II_M.md)

[46.全排列_M](../explain/46.全排列_M.md)

[47. 全排列 II_M](../explain/47.%20全排列%20II_M.md)

[77.组合_M](../explain/77.组合_M.md)

[79.单词搜索_M](../explain/79.单词搜索_M.md)

[131.分割回文串_M](../explain/131.分割回文串_M.md)

[1688.比赛中的配对次数_E](../explain/1688.比赛中的配对次数_E.md)


回溯法的时间复杂度一般不直接算，而是算解空间（有多少个解）

排列树：O(n!)

子集树：O(2^n)

回溯法可以看作蛮力法的升级版，它在解决问题时的每一步都尝试所有可能的选项，最终找出所有可行的解决方案。回溯法非常适合解决由多个步骤组成的问题，并且每个步骤都有多个选项。在某一步选择了其中一个选项之后，就进入下一步，然后会面临新的选项。就这样重复选择，直至到达最终的状态。

用回溯法解决问题的过程可以形象地用一个树形结构表示，求解问题的每个步骤可以看作树中的一个节点。如果在某一步有n个可能的选项，每个选项是树中的一条边，经过这些边就可以到达该节点的n个子节点。

在采用回溯法解决问题时如果到达树形结构的叶节点，就找到了问题的一个解。如果希望找到更多的解，那么还可以回溯到它的父节点再尝试父节点其他的选项。如果父节点所有可能的选项都已经试过，那么再回溯到父节点的父节点以尝试它的其他选项，这样逐层回溯到树的根节点。因此，采用回溯法解决问题的过程实质上是在树形结构中从根节点开始进行深度优先遍历。通常，回溯法的深度优先遍历用递归代码实现。

如果在前往某个节点时对问题的解的状态进行了修改，那么在回溯到它的父节点时要记得清除相应的修改。

由于回溯法是在所有选项形成的树上进行深度优先遍历，如果解决问题的步骤较多或每个步骤都面临多个选项，那么遍历整棵树将需要较多的时间。如果明确知道某些子树没有必要遍历，那么在遍历的时候应该避开这些子树以优化效率。通常将使用回溯法时避免遍历不必要的子树的方法称为剪枝。

怎么样写回溯算法(从上而下，※代表难点，根据题目而变化)
①画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要※
②根据题意，确立结束条件
③找准选择列表(与函数参数相关),与第一步紧密关联※
④判断是否需要剪枝
⑤作出选择，递归调用，进入下一层
⑥撤销选择

模板

```
res = []
path = []

def backtrack(未探索区域, res, path):
    if 未探索区域满足结束条件:
        res.add(path) # 深度拷贝
        return
    for 选择 in 未探索区域当前可能的选择:
        if 当前选择符合要求:
            path.add(当前选择)
            backtrack(新的未探索区域, res, path)
            path.pop()

作者：fuxuemingzhu
链接：https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-fa-si-lu-yu-mo-ban-by-fuxuemingzh-azhz/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```


链接：https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/

**集合的组合、排列**

从一个包含m个元素的集合中挑选出n个元素（0≤n≤m）形成一个子集。一个子集又可以称为一个组合。如果两个子集（组合）的元素完全相同只是顺序不同，那么它们可以看作同一个子集（组合）。

从一个包含m个元素的集合中挑选出n个元素（0≤n≤m）并按照某种顺序形成一个排列。m等于n的排列又称为全排列。如果两个排列的元素完全相同只是顺序不同，那么它们就是两个不同的排列。也就是说，排列与元素的顺序相关，这一点与组合不同。

子集（组合）、排列是数学中很重要的两个概念，在编程面试中也经常遇到。

组合问题，相对于排列问题而言，不计较一个组合内元素的顺序性（即 [1, 2, 3] 与 [1, 3, 2] 认为是同一个组合），因此很多时候需要按某种顺序展开搜索，这样才能做到不重不漏。


[78. 子集_M](../explain/78.%20子集_M.md)

[77.组合_M](../explain/77.组合_M.md)

[39. 组合总和_M](../explain/39.%20组合总和_M.md)
