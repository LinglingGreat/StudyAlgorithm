## 高德纳

图灵提出了计算机的数学模型，冯·诺依曼确定了计算机通用的系统结构，而高德纳则奠定了计算机算法的基础。

高德纳**Donald Ervin Knuth**
- 计算机算法分析的鼻祖，提出了评估计算机算法的标准
- 编写了计算机科学领域的“圣经”——《计算机程序设计艺术》
- 迄今为止最年轻的图灵奖获得者
- 写了一个排版软件TeX（后来被人做成了更方便使用的LaTeX）
- 是硅谷地区众多图灵奖获得者中名气最大、最会编程的人。总是力争一次全对，没有错误，而且算法在设计时就达到最佳。

冯·诺依曼发明计算机体系结构和高德纳编写TeX程序似乎都是偶然为之的结果。冯·诺依曼原本不想发明计算机，他只想算题；高德纳也不想发明排版软件，他只想写书。为什么这些大师们偶然为之的工作比二流人才穷其一生的发现有时还有影响力呢？因为除了能力的差异外，他们还有着**遇到问题时解决问题的积极态度**。任何人在前进的过程中都会遇到问题，但是对待问题的态度决定了个人的命运。

## 大数和数量级

哪个算法更好一些？

早期科学家们的看法不统一，这个没有明确的答案。直到1965年尤里斯·哈特马尼斯（Juris Hartmanis）和理查德·斯特恩斯（Richard Stearns）提出了算法复杂度的概念（二人后来因此获得了图灵奖），计算机科学家才开始考虑用一种公平、一致的评判方法来对比不同算法的性能。最早将算法复杂度严格量化衡量的就是高德纳，他也因此被誉为“算法分析之父”。

高德纳的思想主要包括以下三个部分。

1．在比较算法的快慢时，只需要考虑数据量特别大，大到近乎无穷大时的情况。因为计算机的发明就是为了处理大量数据的，而且数据越处理越多。

2．决定算法快慢的因素虽然可能有很多，但是所有的因素都可以被分为两类：第一类是不随数据量变化的因素，第二类是随数据量变化的因素。

3．两种算法在复杂度上相差哪怕只有一点点，N很大之后，效率可能就差出万亿倍了。比如用非常容易想到的选择排序或插入排序和专业人士常用的快速排序对10多亿个QQ号排一次序，计算量分别是大约100亿亿次和30亿次。

相关笔记：[1【数据结构与算法】复杂度分析](../原理/1【数据结构与算法】复杂度分析.md)

## 怎样寻找最好的算法

#### 例题1.3　总和最大区间问题　（难度系数3颗星)

给定一个实数序列，设计一个最有效的算法，找到一个总和最大的区间。

比如在下面的序列中：

1.5, −12.3, 3.2, −5.5, 23.2, 3.2, −1.4, −12.2, 34.2, 5.4, −7.8, 1.1, −4.9

总和最大的区间是从第5个数（23.2）到第10个数（5.4）。

类似题目：[53. 最大子序和_E](../explain/53.%20最大子序和_E.md)


解决这个问题有四种可行的方法，下面根据计算复杂度从高到低的次序逐一介绍。

**方法1，做一次三重循环，其实就是中学里学的排列组合的方法。**

我们假设这个序列有$K$个数，依次是$a_1,a_1,a_2,…,a_K$。假定区间起始的数字序号为p，结束的数字序号为q，这些数字的总和为$S(p,q)$，则$S(p,q)=a_p+a_p+1+…+a_q$。

p可以从1一直到K，q可以从p一直到K，这是两重循环了，因此区间一头一尾的组合有$O(K^2)$种。在每一种组合中，计算$S(p,q)$平均要做K/4次加法，这是又一重循环。因此这种算法的复杂度是$O(K^3)$。

计算$S(p,q)$平均要做K/4次加法：?

**方法2，做两重循环。**

方法1效率不高的原因是做了太多的无用功，比如当我们把区间的起点定在了位置p之后，如果已经计算了从p到q之间的数字的总和S(p,q)，下次再计算从p到q+1之间的数字的总和S(p,q+1)时，只需要在原来的基础上再做一次加法，而不需要再来一次循环。我们只需要记录三个中间值。

第一个值是从p开始到当前位置q为止的总和S(p,q)，因为我们接下来计算S(p,q+1)时要用到它。

第二个值则是从p开始到当前位置q为止所有总和中最大的那个值，我们假定为Max。有了这个值之后，如果S(_p_,_q_+1)≤Max，则Max维持不变；如果S(p,q+1)>Max，则要更新Max，当然，我们也要记录下来Max是在区间[p,q+1]取得的。

因此，第三个要记录的值就是区间结束的位置，我们不妨以r来表示。如果Max的值更新了，相应的区间结束位置也要更新为q+1。

对于给定的p，需要从头到尾试K−p次，也就是O(K)的复杂度。而p可以从1到K，有K种可能性，二者的组合就是O(K^2)。如果K有好几万，计算量是十几亿，而方法1的计算量是它的上万倍。如果你能想到这种方法，那就基本上达到了五级工程师的要求，因为你已经搞清楚哪些计算是重复计算了。

**方法3，利用分治（Divide-and-Conquer）算法。**

首先，将序列一分为二，分成从1到K/2(如果是奇数，就是(K-1)/2)，以及从K/2+1到K两个子序列。

然后，我们对这两个子序列分别求它们的总和最大区间。接下来有两种情况。

1．前后两个子序列的总和最大区间中间没有间隔，也就是说，前一个子序列的总和最大区间是[p,K/2]，后一个总和最大区间恰好是[K/2+1,q]。如果两个区间各自的和均为正整数，这时，整个序列总和最大区间就是[p, q]；否则，就选取两个子序列的总和最大区间中大的一个。

2．前后两个子序列的总和最大区间中间有间隔，我们假定这两个子序列的总和最大区间分别是[p1,q1]和[p2,q2]。这时，整个序列的总和最大区间是下面三者中最大的那一个：

（1）[p1,q1]；

（2）[p2,q2]；

（3）[p1,q2]。

为什么？

上述三个区间的总和，前两个是已经计算出的，第三个其实是对从q1+1到p2+1之间的数字求和，复杂度为O(K)。有了上面三个值，挑出最大的一个即可。

至于每个子序列的总和最大区间如何求，可以用到递归算法，这种算法的耗时为O(KLogK)。对于几万个数据的序列，计算量为百万级，这比方法2的十几亿又小了不少（是方法2的千分之几）。如果你能够想出这种方法，那在计算机科学的理论上就具备了成为四级工程师的条件，因为你已经掌握了计算机科学的一个精髓——分治算法。当然，一个工程师合格与否要看这个人能否做出实际的产品，除了理解算法，还需要在实际工作中历练。


**方法4，正、反两遍扫描的方法。**

这种方法也是在方法2基础上的改进。在方法2中，我们是先设定区间的左边界p，在此条件下确定总和最大区间的右边界q。然后再改变左边界，测试所有的可能性。但实际上，这种方法在无形中已经找到了总和最大区间的右边界。我们从这个想法出发，来寻找一下线性复杂度，即O(_K_)的算法，步骤如下。

步骤1，先在序列中扫描找到第一个大于零的数，假定这个数不存在（即所有的数字非零即负），那么整个序列中最大的那个数就是所要找的区间。这时算法的复杂度是O(K)。因此，我们可以不失一般性地假设第一个数字是正数，如果这个数小于或等于零，则从序列头部删除，如此反复，最终删除序列头部连续排列的负数或零。

步骤2，我们用类似于方法2中的做法，先把左边界固定在第一个数，然后让_q_=2,3,…,_K_，计算_S_(1,_q_)，以及到目前为止的最大值_Maxf_和达到最大值的右边界_r_。

步骤3，如果对于所有的_q_，都有_S_(1,_q_)≥0，或者存在某个_q_0，当_q_＞_q_0，上述条件满足，这个情况比较简单。当扫描到最后，即_q_=_K_时，所保留的那个_Maxf_所对应的_r_就是我们要找的区间的右边界。为什么呢？因为从第_r_+1个数往后加，无论怎么加，都是负数（或者零），所以右边界不可能往后延长了。为了便于大家理解，我们使用例题1.3中的数据，从前往后一步步累加计算一遍，计算结果放在了表1.1中。从算得的结果可知_Maxf_=39.3，相应的_r_=10。在相应的图1.2中，就是前向累计之和曲线上用圆圈表示的位置。

表1.1　序列中的元素、前向累计之和和后向累计之和

![](https://oss.linklearner.com/the-soul-of-calculation/table_1.1.png)





蒂姆排序


## 例题

#### 1.1围棋有多复杂？（难度系数1颗星）

棋盘上每一个点最终可以是黑子、白子或者空位三种情况，而棋盘有361个交叉点，因此围棋的变化最多可以有3^361≈2×10^172种情况。这个数当然相当大，大约是2后面跟172个零

整个宇宙中不过才有10^79～10^83个基本粒子。也就是说，如果把每一个基本粒子都变成一个宇宙，再把那么多宇宙中的基本粒子数一遍，数量也没有围棋棋盘上各种变化的总数大。

#### 1.2一句有20个单词的英语语句可以有多少种组合？　（难度系数3颗星）

英语的单词数在10万个以上，这里就算是10万个，20个单词不受限制的组合数是10^100。这个数就是古戈尔（Googol），也比宇宙中基本粒子的数量要多得多。如果随便一句话从理论上讲都有这么多的可能性，那么语音识别就是一个在巨大的多维空间中搜索一个点的问题。

葛立恒数是由美国数学家葛立恒（Ronald Graham）提出的，它大得无法用科学记数法来表示，1980 年被吉尼斯世界纪录确认为当时数学上可以证明存在的最大的数。




## 思考题

#### 1.1世界上还有什么产品类似于计算机，是软硬件分离的？（ 难度系数1颗星）


#### 1.2如果一个程序只运行一次，在编写它的时候，你是采用最直观但是效率较低的算法，还是依然寻找复杂度最优的算法？（难度系数2颗星）




Q1．将例题1.3的线性复杂度算法写成伪代码。（难度系数2颗星）




Q2．在一个数组中寻找一个区间，使得区间内的数字之和等于某个事先给定的数字。

（AB、FB、LK等公司的面试题，后面会解答。（难度系数3颗星））




Q3．在一个二维矩阵中，寻找一个矩形的区域，使其中的数字之和达到最大值。

（例题1.3的变种，硅谷公司真实的面试题。（难度系数4颗星））


