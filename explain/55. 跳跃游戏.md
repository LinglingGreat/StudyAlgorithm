---
title: 55. 跳跃游戏
created: 2025-01-07
tags:
  - 难度/中等
  - 主题/贪心算法
---
[55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

**输入：**nums = [2,3,1,1,4]
**输出：**true
**解释：**可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

**示例 2：**

**输入：**nums = [3,2,1,0,4]
**输出：**false
**解释：**无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。

**提示：**

- `1 <= nums.length <= 10^4`
- `0 <= nums[i] <= 10^5`

## 思路

我们先思考暴力穷举解法吧，如何穷举所有可能的跳跃路径？你心里的那棵多叉树画出来了没有？

假设 `N` 为 `nums` 的长度，这道题相当于做 `N` 次选择，每次选择有 `nums[i]` 种选项，想要穷举所有的跳跃路径，就是一棵高度为 `N` 的多叉树，每个节点有 `nums[i]` 个子节点。

这个算法本质上还是穷举了所有可能的选择，可以走动态规划那一套流程进行优化，但是这里我们先不急，可以再仔细想想，这个问题有没有贪心选择性质？

题目的关键点：

1、在索引 `i`，可以跳跃 `1 ~ nums[i]` 步。

2、只要能跳到最后一个索引，就返回 `true`。

这里面有个细节，比方说你现在站在 `nums[i] = 3` 的位置，你可以跳到 `i+1, i+2, i+3` 三个位置，此时你真的需要分别跳过去，然后递归求解子问题 `dp(i+1), dp(i+2), dp(i+3)`，最后通过子问题的答案来决定 `dp(i)` 的结果吗？

其实不用的，`i+1, i+2, i+3` 三个候选项，它们谁能走得最远，你就选谁，准没错。

具体来说，`i+1` 能走到的最远距离是 `i+1+nums[i+1]`，`i+2` 能走到的最远距离是 `i+2+nums[i+2]`，`i+3` 能走到的最远距离是 `i+3+nums[i+3]`，你看看谁最大，就选谁。

这就是贪心选择性质，通过局部最优解就能推导全局最优解，不需要等到递归计算出所有子问题的答案才能做选择。

所以这道题的最优解法如下：

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        farthest = 0
        for i in range(n - 1):
            # 不断计算能跳到的最远距离
            farthest = max(farthest, i + nums[i])
            # 可能碰到了 0，卡住跳不动了
            if farthest <= i:
                return False
        return farthest >= n - 1
```

只需要遍历所有元素，记录当前能到达的最远位置就行了，时间复杂度是 O(N)，空间复杂度是 O(1)，非常高效。
