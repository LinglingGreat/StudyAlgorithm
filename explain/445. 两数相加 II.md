---
title: 445. 两数相加 II
created: 2025-01-05
tags:
  - 难度/中等
  - 数据结构/链表
---
[445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)

给你两个 **非空** 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

你可以假设除了数字 0 之外，这两个数字都不会以零开头。

**示例1：**

![](https://labuladong.online/algo/images/lc/1626420025-fZfzMX-image.png)

**输入：**l1 = [7,2,4,3], l2 = [5,6,4]
**输出：**[7,8,0,7]

**示例2：**

**输入：**l1 = [2,4,3], l2 = [5,6,4]
**输出：**[8,0,7]

**示例3：**

**输入：**l1 = [0], l2 = [0]
**输出：**[0]

**提示：**

- 链表的长度范围为 `[1, 100]`
- `0 <= node.val <= 9`
- 输入数据保证链表代表的数字无前导 0

**进阶：**如果输入链表不能翻转该如何解决？

## 思路

这道题是 [2. 两数相加](https://leetcode.cn/problems/add-two-numbers) 的进阶问题，我们模拟加法运算当然是从最低位开始加，这样才能正确的处理进位。但现在单链表的开头是最高位，那么最直接的想法就是先 [翻转链表](https://labuladong.online/algo/data-structure/reverse-linked-list-recursion/)，这样就可以继续玩第 2 题那一套了，没什么难度。

不过本题也说了，如果不让你反转链表怎么办？其实也好办，我们可以利用栈这种先进后出的数据结构，把链表节点从头到尾放进栈中，再从栈拿出来就是从尾到头的顺序，相当于是反转链表的效果，然后又回到了第 2 题的加法逻辑。

还有一个需要注意的是，计算结果的高位也应该放在结果链表的左侧，也就是插入到 `dummy` 节点的后面。具体看代码吧。

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译。
# 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        # 把链表元素转入栈中
        stk1 = []
        while l1:
            stk1.append(l1.val)
            l1 = l1.next
        stk2 = []
        while l2:
            stk2.append(l2.val)
            l2 = l2.next

        # 接下来基本上是复用我在第 2 题的代码逻辑
        # 注意新节点要直接插入到 dummy 后面

        # 虚拟头结点（构建新链表时的常用技巧）
        dummy = ListNode(-1)

        # 记录进位
        carry = 0
        # 开始执行加法，两条链表走完且没有进位时才能结束循环
        while stk1 or stk2 or carry > 0:
            # 先加上上次的进位
            val = carry
            if stk1:
                val += stk1.pop()
            if stk2:
                val += stk2.pop()
            # 处理进位情况
            carry = val // 10
            val = val % 10
            # 构建新节点，直接接在 dummy 后面
            newNode = ListNode(val)
            newNode.next = dummy.next
            dummy.next = newNode

        # 返回结果链表的头结点（去除虚拟头结点）
        return dummy.next
```

```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        s1, s2 = [], []
        while l1:
            s1.append(l1.val)
            l1 = l1.next
        while l2:
            s2.append(l2.val)
            l2 = l2.next
        ans = None
        carry = 0
        while s1 or s2 or carry != 0:
            a = 0 if not s1 else s1.pop()
            b = 0 if not s2 else s2.pop()
            cur = a + b + carry
            carry = cur // 10
            cur %= 10
            curnode = ListNode(cur)
            curnode.next = ans
            ans = curnode
        return ans

作者：力扣官方题解
链接：https://leetcode.cn/problems/add-two-numbers-ii/solutions/200585/liang-shu-xiang-jia-ii-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

复杂度分析

时间复杂度：O(max(m,n))，其中 m 和 n 分别为两个链表的长度。我们需要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间。

空间复杂度：O(m+n)，其中 m 和 n 分别为两个链表的长度。空间复杂度主要取决于我们把链表内容放入栈中所用的空间。