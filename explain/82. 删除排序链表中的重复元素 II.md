---
title: 82. 删除排序链表中的重复元素 II
created: 2025-01-05
tags:
  - 难度/中等
  - 主题/双指针
  - 数据结构/链表
  - 主题/链表分解
---
[82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

给定一个已排序的链表的头 `head` ， _删除原始链表中所有重复数字的节点，只留下不同的数字_ 。返回 _已排序的链表_ 。

**输入：**head = [1,2,3,3,4,4,5]
**输出：**[1,2,5]

**提示：**

- 链表中节点数目在范围 `[0, 300]` 内
- `-100 <= Node.val <= 100`
- 题目数据保证链表已经按升序 **排列**


这道题可以有多种解法，最简单粗暴的解法是用 [哈希集合](https://labuladong.online/algo/data-structure-basic/hash-set/) 来记录重复节点，需要额外的空间复杂度，我们不讨论。下面探讨如何用双指针技巧，避免使用额外的空间复杂度来求解。

第一种思路，也是我比较推荐的方式，就是把这种题转化成 [链表的双指针技巧汇总](https://labuladong.online/algo/essential-technique/array-two-pointers-summary/) 中讲的链表分解的技巧。题目其实就是让你把链表分解成「重复元素」和「不重复元素」两条链表，然后把不重复元素这条链表返回即可。

第二种思路，可以把这道题理解为 [链表的双指针技巧汇总](https://labuladong.online/algo/essential-technique/array-two-pointers-summary/) 中讲的 [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list) 的变体，只不过 83 题让你把多于的重复元素去掉，这道题要求你把所有重复的元素全都去掉。

第三种思路，可以用递归思维来做，稍微难理解一些.

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译。
# 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

# 推荐的通用解法，运用链表分解的技巧
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        # 将原链表分解为两条链表
        # 一条链表存放不重复的节点，另一条链表存放重复的节点
        # 运用虚拟头结点技巧，题目说了 node.val <= 100，所以用 101 作为虚拟头结点
        dummyUniq = ListNode(101)
        dummyDup = ListNode(101)

        pUniq, pDup = dummyUniq, dummyDup
        p = head

        while p is not None:
            if (p.next is not None and p.val == p.next.val) or p.val == pDup.val:
                # 发现重复节点，接到重复链表后面
                pDup.next = p
                pDup = pDup.next
            else:
                # 不是重复节点，接到不重复链表后面
                pUniq.next = p
                pUniq = pUniq.next

            p = p.next
            # 将原链表和新链表断开
            pUniq.next = None
            pDup.next = None

        return dummyUniq.next

# 快慢双指针解法
class Solution2:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1)
        p, q = dummy, head
        while q is not None:
            if q.next is not None and q.val == q.next.val:
                # 发现重复节点，跳过这些重复节点
                while q.next is not None and q.val == q.next.val:
                    q = q.next
                q = q.next
                # 此时 q 跳过了这一段重复元素
                if q is None:
                    p.next = None
                # 不过下一段元素也可能重复，等下一轮 while 循环判断
            else:
                # 不是重复节点，接到 dummy 后面
                p.next = q
                p = p.next
                q = q.next
        return dummy.next

# 递归解法
class Solution3:
    # 定义：输入一条单链表头结点，返回去重之后的单链表头结点
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        # base case
        if head is None or head.next is None:
            return head
        if head.val != head.next.val:
            # 如果头结点和身后节点的值不同，则对之后的链表去重即可
            head.next = self.deleteDuplicates(head.next)
            return head
        # 如果如果头结点和身后节点的值相同，则说明从 head 开始存在若干重复节点
        # 越过重复节点，找到 head 之后那个不重复的节点
        while head.next is not None and head.val == head.next.val:
            head = head.next
        # 直接返回那个不重复节点开头的链表的去重结果，就把重复节点删掉了
        return self.deleteDuplicates(head.next)
```


https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81

