---
title: 86. 分隔链表_M
created: 2025-01-05
tags:
  - 难度/中等
  - 主题/双指针
  - 数据结构/链表
---

#### [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)

解题记录

- 2021/08/12 基本上独立解出

给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。

你应当 保留 两个分区中每个节点的初始相对位置。
 

示例 1：


输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
示例 2：

输入：head = [2,1], x = 2
输出：[1,2]


提示：

链表中节点的数目在范围 [0, 200] 内
-100 <= Node.val <= 100
-200 <= x <= 200

#### 方法一：模拟/双指针

直观来说我们只需维护两个链表 small 和 large 即可，small 链表按顺序存储所有小于 x 的节点，large 链表按顺序存储所有大于等于 x 的节点。遍历完原链表后，我们只要将 small 链表尾节点指向large 链表的头节点即能完成对链表的分隔。

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/partition-list/solution/fen-ge-lian-biao-by-leetcode-solution-7ade/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```Python
class Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        small = ListNode(0)
        smallhead = small
        large = ListNode(0)
        largehead = large
        while head:
            if head.val < x:
                small.next = head
                small = small.next
            else:
                large.next = head
                large = large.next
            head = head.next
            # 不能直接让 head 指针前进？ 
            # 断开原链表中的每个节点的 next 指针 
            # temp = head.next 
            # head.next = None 
            # head = temp
        large.next = None
        small.next = largehead.next
        return smallhead.next
```

如果我们需要把原链表的节点接到新链表上，而不是 new 新节点来组成新链表的话，那么断开节点和原链表之间的链接可能是必要的。那其实我们可以养成一个好习惯，但凡遇到这种情况，就把原链表的节点断开，这样就不会出错了。

方法二

```python
class Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        dummyNode = ListNode(0)
        dummyNode.next = head
        pos = dummyNode
        # 找到第一个比x大的结点的前一个结点,作为插入点
        while pos.next and pos.next.val < x:
            pos = pos.next
        newcur = pos
        # 将小的值插入pos后面
        while newcur and newcur.next:
            if newcur.next.val < x:
                tmp1 = pos.next
                tmp2 = newcur.next
                pos.next = newcur.next
                newcur.next = tmp2.next
                tmp2.next = tmp1
                pos = pos.next  # 更新插入点
            else:
                newcur = newcur.next
        return dummyNode.next
```

2021/08/12

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        head0 = ListNode(0)
        head0.next = head
        ins = head0
        while ins.next and ins.next.val < x:
            ins = ins.next
        cur = ins
        while cur and cur.next:
            if cur.next.val < x:
                cur.next.next, ins.next, cur.next = ins.next, cur.next, cur.next.next
                ins = ins.next
            else:
                cur = cur.next
        return head0.next

```





