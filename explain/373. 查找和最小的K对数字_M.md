---
title: 373. 查找和最小的K对数字_M
created: 2025-01-05
tags:
  - 难度/中等
  - 数据结构/堆
  - 数据结构/数组
  - 主题/二分查找
  - 主题/链表合并
---

#### [373. 查找和最小的K对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)

难度：中等

标签：[数组](../原理/数组.md)，[堆](../原理/堆.md)

相同题目：[剑指 Offer II 061. 和最小的 k 个数对](https://leetcode-cn.com/problems/qn8gGX/)

给定两个以**非递减顺序排列**排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。

定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。

请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。

 

示例 1:

输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [1,2],[1,4],[1,6]
解释: 返回序列中的前 3 对数：
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
示例 2:

输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
输出: [1,1],[1,1]
解释: 返回序列中的前 2 对数：
     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
示例 3:

输入: nums1 = [1,2], nums2 = [3], k = 3 
输出: [1,3],[2,3]
解释: 也可能序列中所有的数对都被返回:[1,3],[2,3]


提示:

1 <= nums1.length, nums2.length <= 10^4
-10^9 <= nums1[i], nums2[i] <= 10^9
nums1, nums2 均为升序排列
1 <= k <= 1000

## 思路

这道题其实是 [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists) 的变体。

怎么把这道题变成合并多个有序链表呢？就比如说题目输入的用例：

```
nums1 = [1,7,11], nums2 = [2,4,6]
```

组合出的所有数对儿这就可以抽象成三个有序链表：

```
[1, 2] -> [1, 4] -> [1, 6]
[7, 2] -> [7, 4] -> [7, 6]
[11, 2] -> [11, 4] -> [11, 6]
```

这三个链表中每个元素（数对之和）是递增的，所以就可以按照 [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists) 的思路来合并，取出前 `k` 个作为答案即可。

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译。
# 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

from queue import PriorityQueue

class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        # 存储三元组 (num1[i], nums2[i], i)
        # i 记录 nums2 元素的索引位置，用于生成下一个节点
        pq = PriorityQueue()
        
        # 按照 23 题的逻辑初始化优先级队列
        for i in range(len(nums1)):
            pq.put((nums1[i] + nums2[0], nums1[i], nums2[0], 0))

        res = []
        # 执行合并多个有序链表的逻辑
        while not pq.empty() and k > 0:
            _, num1, num2, idx = pq.get()
            k -= 1
            # 链表中的下一个节点加入优先级队列
            next_index = idx + 1
            if next_index < len(nums2):
                pq.put((num1 + nums2[next_index], num1, nums2[next_index], next_index))

            # 按照数对的元素和升序排序
            pair = [num1, num2]
            res.append(pair)

        return res
```

#### 最大堆

可以用最大堆来存储这k个和最小的数对。逐一将m×n个数对添加到最大堆中。

题目给出的条件是输入的两个数组都是递增排序的。不管输入的数组nums1有多长，最多只需要考虑前k个数字。同理，不管输入的数组nums2有多长，最多也只需要考虑前k个数字。



```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        heap = []
        # 官方实现的是最小堆，若想实现最大堆，仅需要将每个元素的 键 值添负号。
        for a in nums1:
            for b in nums2:
                if len(heap) < k:
                    heapq.heappush(heap, (-(a + b), [a, b]))
                elif -(a + b) > heap[0][0]:
                    heapq.heappushpop(heap, (-(a + b), [a, b]))
                else:
                    break
        ans = []
        while heap:
            t = heapq.heappop(heap, )
            ans.append(t[1])
        ans.reverse()
        return ans
```

上述代码有两个相互嵌套的for循环，每个循环最多执行k次。在循环体内可能在最大堆中进行添加或删除操作，由于最大堆中最多包含k个元素，因此添加、删除操作的时间复杂都是O（logk）。这两个for循环的时间复杂度是O（k^2logk）。另外，上述代码还有一个while循环，它逐一从最大堆中删除元素并将对应的数对添加到链表中，这个while循环的时间复杂度是O（klogk）。因此，上述代码总的时间复杂度是O（k^2logk）。

#### 最小堆

剑指offer

如果输入两个数组[1，5，13，21]和[2，4，9，15]求取和最小的3个数对，那么先从第1个数组中选取最前面的3个数字1、5、13，它们分别和第2个数组的第1个数字2组成3个数对（1，2）、（5，2）、（13，2）。这3个候选的数对中和最小的数对为（1，2）。

找出（1，2）这个和最小的数对之后，接着找下一个和最小的数对。由于数对（1，2）的两个数字1和2在两个数组中的下标都是0，因此下一个和最小的数对既可能是由第1个数组中下标为0和第2个数组中下标为1的两个数字组成的，即数对（1，4），也可能是由第1个数组中下标为1和第2个数组中下标为0的两个数字组成的，即数对（5，2）。数对（5，2）已经在候选的数对中，所以在候选的数对中添加数对（1，4）即可。将这个新添加的数对与前一个和最小的数对（1，2）进行比较可以发现，它们的第1个数字是相同的，但第2个数字在第2个数组中下标增加了1。在3个候选的数对（1，4）、（5，2）、（13，2）中和最小的数对是（1，4）。

数对（1，4）的两个数字1和4在两个数组中的下标分别为0和1。接下来将由第1个数组中下标为0的数字和第2个数组中下标为2的数字组成的数对（1，9）添加到候选数对中。3个候选数对（1，9）、（5，2）、（13，2）中和最小的数对是（5，2）。

（a）在（1，2）、（5，2）、（13，2）这3个数对中选出和最小的数对（1，2）；（b）在（1，4）、（5，2）、（13，2）这3个数对中选出和最小的数对（1，4）；（c）在（1，9）、（5，2）、（13，2）这3个数对中选出和最小的数对（2，5）

由于每次都是从3个候选的数对中选取和最小的数对，因此可以用一个最小堆来存储候选的数对。如果和最小的数对的两个数字在两个数组中的下标分别为i1和i2，将该数对添加到结果中并将其从最小堆中删除，再将在两个数组中下标分别为i1和i2+1的两个数字作为新的候选数对添加到最小堆中。

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        heap = []
        # 最小堆，选出候选中最小的数对
        if len(nums2) > 0:
            for i, a in enumerate(nums1[:k]):
                heapq.heappush(heap, (nums1[i]+nums2[0],i, 0))
        result = []
        while k > 0 and heap:
            t = heapq.heappop(heap)
            result.append([nums1[t[1]], nums2[t[2]]])
            k -= 1
            if t[2] < len(nums2)-1:
                heapq.heappush(heap, (nums1[t[1]]+nums2[t[2]+1],t[1], t[2]+1))
        return result
```



上述代码先用一个for循环构建一个大小为k的最小堆，该循环的时间复杂度是O（klogk）。接下来是一个执行k次的while循环，每次对大小为k的最小堆进行添加或删除操作，因此这个while循环的时间复杂度也是O（klogk）。上述代码总的时间复杂度为O（klogk）。

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        m, n = len(nums1), len(nums2)
        ans = []
        pq = [(nums1[i] + nums2[0], i, 0) for i in range(min(k, m))]
        while pq and len(ans) < k:
            _, i, j = heappop(pq)
            ans.append([nums1[i], nums2[j]])
            if j + 1 < n:
                heappush(pq, (nums1[i] + nums2[j + 1], i, j + 1))
        return ans

作者：力扣官方题解
链接：https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/solutions/1208350/cha-zhao-he-zui-xiao-de-kdui-shu-zi-by-l-z526/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

二分查找

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        m, n = len(nums1), len(nums2)

        # 二分查找第 k 小的数对和
        left, right = nums1[0] + nums2[0], nums1[m - 1] + nums2[n - 1] + 1
        while left < right:
            mid = (left + right) // 2
            cnt = 0
            i, j = 0, n - 1
            while i < m and j >= 0:
                if nums1[i] + nums2[j] > mid:
                    j -= 1
                else:
                    cnt += j + 1
                    i += 1
            if cnt < k:
                left = mid + 1
            else:
                right = mid
        pairSum = left

        ans = []
        # 找数对和小于 pairSum 的数对
        i = n - 1
        for num1 in nums1:
            while i >= 0 and num1 + nums2[i] >= pairSum:
                i -= 1
            for j in range(i + 1):
                ans.append([num1, nums2[j]])
                if len(ans) == k:
                    return ans

        # 找数对和等于 pairSum 的数对
        i = n - 1
        for num1 in nums1:
            while i >= 0 and num1 + nums2[i] > pairSum:
                i -= 1
            j = i
            while j >= 0 and num1 + nums2[j] == pairSum:
                ans.append([num1, nums2[j]])
                if len(ans) == k:
                    return ans
                j -= 1
        return ans

作者：力扣官方题解
链接：https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/solutions/1208350/cha-zhao-he-zui-xiao-de-kdui-shu-zi-by-l-z526/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```