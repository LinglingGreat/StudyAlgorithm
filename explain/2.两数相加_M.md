---
title: 2.两数相加_M
created: 2025-01-05
tags:
  - 难度/中等
  - 数据结构/链表
---

#### [2\. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

难度：中等

标签：[递归](../原理/递归.md)，[数学](../原理/数学.md)，[链表](../原理/链表.md)

解题记录

- 2021/08/12 独立解出

### 题目描述

给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。

你可以假设除了数字 0 之外，这两个数字都不会以零开头。

示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807



单链表的定义是这样的：

```python
class ListNode:
	def __init__(self, x):
		self.val = x
		self.next = None
```

### 思路

逆序存储很友好了，直接遍历链表就是从个位开始的，符合我们计算加法的习惯顺序。如果是正序存储，那倒要费点脑筋了，可能需要 [翻转链表](https://labuladong.online/algo/data-structure/reverse-linked-list-recursion/) 或者使用栈来辅助。

这道题主要考察 [链表双指针技巧](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/) 和加法运算过程中对进位的处理。注意这个 `carry` 变量的处理，在我们手动模拟加法过程的时候会经常用到。

**代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 `dummy` 节点**。你可以试试，如果不使用 `dummy` 虚拟节点，代码会稍显复杂，而有了 `dummy` 节点这个占位符，可以避免处理初始的空指针情况，降低代码的复杂性。

解法一：只需要按逆序的顺序将各位数加起来即可，有进位的地方标志一下。

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译。
# 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        # 在两条链表上的指针
        p1, p2 = l1, l2
        # 虚拟头结点（构建新链表时的常用技巧）
        dummy = ListNode(-1)
        # 指针 p 负责构建新链表
        p = dummy
        # 记录进位
        carry = 0
        # 开始执行加法，两条链表走完且没有进位时才能结束循环
        while p1 is not None or p2 is not None or carry > 0:
            # 先加上上次的进位
            val = carry
            if p1 is not None:
                val += p1.val
                p1 = p1.next
            if p2 is not None:
                val += p2.val
                p2 = p2.next
            # 处理进位情况
            carry = val // 10
            val = val % 10
            # 构建新节点
            p.next = ListNode(val)
            p = p.next
        # 返回结果链表的头结点（去除虚拟头结点）
        return dummy.next
```

思路一样，但换了种写法：

```python
class Solution:
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        node1 = l1
        node2 = l2
        dummyRoot = ListNode(0)
        ptr = dummyRoot
        carry = 0
        while node1 or node2:
            ptr.next = ListNode((node1.val if node1 else 0) + (node2.val if node2 else 0) + carry)
            ptr = ptr.next
            carry = ptr.val //10
            ptr.val %= 10
            node1 = node1.next if node1 else None
            node2 = node2.next if node2 else None
        if carry:
            ptr.next = ListNode(carry)
        return dummyRoot.next
```

解法二：先把两个数字用int型表示出来，相加之和再存成链表形式：

```python
class Solution:
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """

        sl1 = ''
	    sl2 = ''
	    
	    while l1:
	        sl1 += str(l1.val)
	        l1 = l1.next
	        
	    while l2:
	        sl2 += str(l2.val)
	        l2 = l2.next
	    
	    sum = str(int(sl1[::-1]) + int(sl2[::-1]))
	    
	    head = tail = ListNode(0)
	    
	    for cha in sum[::-1]:
	        cur = ListNode(cha)
	        tail.next = cur
	        tail = cur
	        
	    return head.next
```

上述解法的时间复杂度都是O(max(m,n))，空间复杂度也是O(max(m,n))，其中m和n分别代表两个链表的长度。