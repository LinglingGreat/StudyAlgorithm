#### [132. 分割回文串 II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)

难度：中等

标签：[字符串](../Topic/字符串.md)，[动态规划](../Topic/动态规划.md)

相同题目： [剑指 Offer II 094. 最少回文分割](https://leetcode-cn.com/problems/omKAoA/)

给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。

返回符合要求的 最少分割次数 。

 

示例 1：

输入：s = "aab"
输出：1
解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。
示例 2：

输入：s = "a"
输出：0
示例 3：

输入：s = "ab"
输出：1


提示：

1 <= s.length <= 2000
s 仅由小写英文字母组成



#### 方法一：动态规划

可以将一个字符串切若干刀使每个子字符串都是回文，也就是说，完成一个分割需要多个步骤，而且每个步骤的分割也可能面临多个选择。例如，在考虑分割字符串"aaba"以最后一个字符'a'为结尾字符的回文子字符串时，就有两个选择：一个选择是分割出来的回文子字符串只包含一个字符，即"a"（此时整个字符串"aaba"可以分割出3个回文子字符串"aa"、"b"和"a"）；另一个选择是分割出来的子字符串包含3个字符，即"aba"（此时整个字符串"aaba"可以分割出两个回文子字符串，即"a"和"aba"）。

应用动态规划解决问题的关键在于找出状态转移方程。假设字符串为S，下标为i的字符为S[i]，下标从j到i的子字符串为S[j..i]。用f（i）表示从下标为0到i的子字符串S[0..i]的符合条件的最少分割次数。如果字符串的长度是n，那么f（n-1）就是问题的解。

如果子字符串S[0..i]本身就是一个回文，那么不需要分割就符合要求，此时f（i）等于0。如果子字符串S[0..i]不是一个回文，那么对每个下标j（1≤j≤i）逐一判断子字符串S[j..i]是不是回文。如果是回文，那么这就是一个有效的分割方法，此时的分割次数相当于子字符串S[0..j-1]的分割次数再加1，因为这是将子字符串S[0..j-1]按照要求分割之后再在S[j-1]和S[j]这两个字符中间再分割一次。因此，f（i）就是所有符合条件的j对应的f（j-1）的最小值加1。

```python
class Solution:
    def minCut(self, s: str) -> int:
        n = len(s)
        g = [[True] * n for _ in range(n)]

        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                g[i][j] = (s[i] == s[j]) and g[i + 1][j - 1]

        f = [float("inf")] * n
        for i in range(n):
            if g[0][i]:
                f[i] = 0
            else:
                for j in range(i):
                    if g[j + 1][i]:
                        f[i] = min(f[i], f[j] + 1)
        
        return f[n - 1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/palindrome-partitioning-ii/solution/fen-ge-hui-wen-chuan-ii-by-leetcode-solu-norx/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

上述代码还需要解决一个问题：如何快速判断下标从j到i的子字符串是不是回文？通常需要用O（n）的时间判断一个长度为n的字符串是不是回文。由于需要用二重循环计算状态转移方程，因此如果循环体内还需要O（n）的时间判断子字符串是不是回文，那么总体时间复杂度就是O（n3）。

为了优化时间复杂度，上述代码需要预处理，先判断所有子字符串S[j..i]是不是回文，并将子字符串是否为回文的结果保存在“isPal[j][i]”中。判断子字符串S[j..i]是否为回文的标准是字符S[j]和S[i]相同，并且子字符串S[j+1..i-1]也是回文。优化之后只需要O（1）的时间就能判断子字符串S[j..i]是不是回文。

`由于状态 g[l][r]g[l][r] 依赖于状态 g[l + 1][r - 1]g[l+1][r−1]，因此需要我们左端点 ll 是「从大到小」进行遍历；而右端点 rr 是「从小到大」进行遍历。`



时间复杂度：O(n^2)，其中 n 是字符串 s 的长度。预处理计算 g 和动态规划计算 f 的时间复杂度均为 O(n^2)。

空间复杂度：O(n^2)数组 gg 需要使用 O(n^2)的空间，数组 f 需要使用 O(n)的空间。

