---
title: 45. 跳跃游戏 II
created: 2025-01-07
tags:
  - 难度/中等
  - 主题/贪心算法
---
[45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

**示例 1:**

**输入:** nums = [2,3,1,1,4]
**输出:** 2
**解释:** 跳到最后一个位置的最小跳跃数是 `2`。
     从下标为 0 跳到下标为 1 的位置，跳 `1` 步，然后跳 `3` 步到达数组的最后一个位置。

**示例 2:**

**输入:** nums = [2,3,0,1,4]
**输出:** 2

**提示:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`
- 题目保证可以到达 `nums[n-1]`

## 思路

现在的问题是，保证你一定可以跳到最后一格，请问你最少要跳多少次，才能跳过去。

暴力穷举肯定也是可以做的，就类似上面的那道题，只不过修改一下 `dp` 数组的定义，返回值从 `boolean` 改成 `int`，表示最少需要跳跃的次数就行了。

我们可以定义这样一个 `dp` 函数：

```
# 定义：从索引 p 跳到最后一格，至少需要 dp(nums, p) 步
def dp(nums: List[int], p: int) -> int:
```

题目问的就是 `dp(nums, 0)` 的结果，base case 就是当 `p` 超过最后一格时，不需要跳跃：

```
if (p >= nums.length - 1) {
    return 0;
}
```

根据[动态规划](../原理/动态规划.md)的动规框架，就可以暴力穷举所有可能的跳法，通过备忘录 `memo` 消除重叠子问题，取其中的最小值最为最终答案：

```python
class Solution:
    # 主函数
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        # 备忘录都初始化为 n，相当于 INT_MAX
        # 因为从 0 跳到 n - 1 最多 n - 1 步
        memo = [n] * n

        return self.dp(nums, 0, memo)
    
    # 定义：从索引 p 跳到最后一格，至少需要 dp(nums, p) 步
    def dp(self, nums: List[int], p: int, memo: List[int]) -> int:
        n = len(nums)
        # base case
        if p >= n - 1:
            return 0
        # 子问题已经计算过
        if memo[p] != n:
            return memo[p]
        steps = nums[p]
        # 你可以选择跳 1 步，2 步...
        for i in range(1, steps + 1):
            # 穷举每一个选择
            # 计算每一个子问题的结果
            subProblem = self.dp(nums, p + i, memo)
            # 取其中最小的作为最终结果
            memo[p] = min(memo[p], subProblem + 1)
        return memo[p]
```


这个解法已经通过备忘录消除了冗余计算，时间复杂度是 递归深度 x 每次递归需要的时间复杂度，即 O(N^2)，在 LeetCode 上是无法通过所有用例的，会超时。

所以进一步的优化就只能是贪心算法了，我们要仔细思考是否存在贪心选择性质，是否能够通过局部最优解推导全局最优解，避免全量穷举所有的可能解。

和上面的题目是一样的优化思路：我们真的需要递归地计算出每一个子问题的结果，然后求最值吗？其实不需要。

![](https://labuladong.online/algo/images/jumpGame/1.jpg)

上图这种情况，我们站在索引 0 的位置，可以向前跳 1，2 或 3 步，你说应该选择跳多少呢？

你可以确定地说，应该跳 2 步调到索引 2，因为 `nums[2]` 的可跳跃区域涵盖了索引区间 `[3..6]`，比其他的都大。题目求最少的跳跃次数，那么往索引 2 跳必然是最优的选择。

**这就是贪心选择性质，我们不需要真的递归穷举出所有选择的具体结果来比较求最值，而只需要每次选择那个最有潜力的局部最优解，最终就能得到全局最优解**。

绕过这个弯儿来，就可以写代码了：

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        end = 0
        farthest = 0
        jumps = 0
        for i in range(n - 1):
            farthest = max(nums[i] + i, farthest)
            if end == i:
                jumps += 1
                end = farthest
        return jumps
```

这个解法的时间复杂度是 O(N)，空间复杂度是 O(1)，可以通过所有测试用例。

