---
title: 567. 字符串的排列
created: 2025-01-07
tags:
  - 难度/中等
  - 主题/滑动窗口
---
[567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)

给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的 

排列

。如果是，返回 `true` ；否则，返回 `false` 。

换句话说，`s1` 的排列之一是 `s2` 的 **子串** 。

**示例 1：**

**输入：**s1 = "ab" s2 = "eidbaooo"
**输出：**true
**解释：**s2 包含 s1 的排列之一 ("ba").

**示例 2：**

**输入：**s1= "ab" s2 = "eidboaoo"
**输出：**false

**提示：**

- `1 <= s1.length, s2.length <= 10^4`
- `s1` 和 `s2` 仅包含小写字母

## 滑动窗口

按照滑动窗口的思路写即可，参考[76. 最小覆盖子串](76.%20最小覆盖子串.md)

```python
class Solution:
    # 判断 s 中是否存在 t 的排列
    def checkInclusion(self, t: str, s: str) -> bool:
        need, window = collections.defaultdict(int), collections.defaultdict(int)
        for c in t: 
            need[c] += 1

        left, right, valid = 0, 0, 0 
        while right < len(s):
            c = s[right]
            right += 1
            # 进行窗口内数据的一系列更新
            if c in need:
                window[c] += 1
                if window[c] == need[c]:
                    valid += 1

            # 判断左侧窗口是否要收缩
            while (right - left >= len(t)):
                # 在这里判断是否找到了合法的子串
                if valid == len(need):
                    return True
                d = s[left]
                left += 1
                # 进行窗口内数据的一系列更新
                if d in need:
                    if window[d] == need[d]:
                        valid -= 1
                    window[d] -= 1

        # 未找到符合条件的子串
        return False
```

对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变几个地方：

1、本题移动 `left` 缩小窗口的时机是窗口大小大于 `t.length()` 时，因为排列嘛，显然长度应该是一样的。

2、当发现 `valid == need.size()` 时，就说明窗口中就是一个合法的排列，所以立即返回 `true`。

至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。

小优化

由于这道题中 `[left, right)` 其实维护的是一个**定长**的窗口，窗口长度为 `t.length()`。因为定长窗口每次向前滑动时只会移出一个字符，所以完全可以把内层的 while 改成 if，效果是一样的。